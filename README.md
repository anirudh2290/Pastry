Pastry
======

Team members: Anirudh Subramanian (UFID:94453124), Divya Ramachandran (UFID:46761308)

A program written as part of Distributed Operating Systems course to implement the Pastry protocol and a simple object access service.
Reference: Pastry: Scalable, decentralized object location and routing for large-scale peer-to-peer systems by Antony Rowstron
and Peter Druschel

Input arguments are as follows:
1] numNodes : number of nodes forming the Pastry peer to peer network
2] numRequests : number of requests each peer has to make at the rate of 1 request/second

Example: 10000 5

Output :: Average number of hops taken to route a single message
=============================================================================================================================
Instructions {How to run}

Now from the Pastry-master folder do:

sbt publishLocal

commands(Make sure you are in Pastry-master folder)

sbt runMain project3 numNodes numRequests
============================================================================================================================
Note 

Please refer to excel sheet in the project root folder for our test results

The largest network we tried for is 10000 nodes on a dual core machine for all the topologies and algorithms

===========================================================================================================================
Implementation Details:

Initialisation of the network involves creating actors with randomly generated unique nodeIds to simulate the real world 
IDs generated by hashing the IP or public key of a node as explained in the paper. Initialisation involves setting up of 
the leaf table and routing table by way of sending a message containing its own nodeId to the last generated node assuming 
it to be the closest node (purely an assumption as there is no way to check proximity). Updation of tables of a node on a 
join of a new node as well as routing a message to a specific node is implemented using the routing algorithm proposed  
by the paper considering three different cases of the target nodeId lying within the range of the leafset, or some way via
a node in the routing table or a third case of finding any node in the tables that is numerically closeset to the target 
nodeId. Once a new node's tables are populated, it is sent back to all the nodes contained in its tables in order for those
nodes to update their tables with the information of and from the new node.
Each message holds a hopnumber to keep track of the number of hops it is making to reach its destination to derive an 
average number of hops per message metric. This metric illustrates the effectiveness of the algorithm to ensure that the
messages on an average take O(log N) steps in case of no recent failures.

===========================================================================================================================
Test Results and Analysis:
